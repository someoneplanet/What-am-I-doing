player = game.Players.LocalPlayer
cplayer = player.Character

loadstring(game:HttpGet(('https://pastefy.app/Mb3YfYL8/raw'),true))()

for i,v in pairs (cplayer:GetChildren()) do
	if v:IsA("Accessory") then
		v.Handle.Massless = true
		v.Handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
	end
end

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end

local hat2 = gp(cplayer, "MeshPartAccessory", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"]
att2.Position = Vector3.new(-0, -0, 0)
att2.Rotation = Vector3.new(180, 0, -15)
 
local hat2 = gp(cplayer, "YogaMat_White", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Arm"]
att2.Position = Vector3.new(0.3, -0.2, -0.4)
att2.Rotation = Vector3.new(-100, 0, 0)

local hat2 = gp(cplayer, "Yoga Mat", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(-0.3, -0.2, -0.4)
att2.Rotation = Vector3.new(-100, 0, 0) --LavanderHair

local hat2 = gp(cplayer, "Lipstick_Bag_3.0", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Leg"]
att2.Position = Vector3.new(0, -0, 0.5) --Robloxclassicred
att2.Rotation = Vector3.new(0, -5, -45)

local hat2 = gp(cplayer, "Lipstick_Bag_1.0", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Leg"]
att2.Position = Vector3.new(-0, -0, 0.5) 
att2.Rotation = Vector3.new(0, 0, -45)

local script = game:GetObjects("rbxassetid://10170990440")[1]
	local AHB = Instance.new("BindableEvent")
	
	local FPS = 30
	
	local TimeFrame = 0
	
	local LastFrame = tick()
	local Frame = 1/FPS
	
	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end
-----------------------
--[[ Name : CADUCUS? ]]--
-------------------------------------------------------
--A script By makhail07
 
--Discord Creterisk#2958
 
--NOTE THIS SCRIPT WAS PURELY MADE FROM MY FUCKING IMAGINATION
--IF IT HAPPENS TO LOOK LIKE ANOTHER SCRIPT
--DONT CALL IT A FUCKING BOOTLEG THANK YOU AND ENJOY THE SCRIPT
--YOU FUCKING SKIDS,
--For Those who log/decompile this, If you sell or trade this,
--and I find out who you are, i will take massive action.
 
-------------------------------------------------------
 
local FavIDs = {
    340106355, --Nefl Crystals
    927529620, --Dimension
    876981900, --Fantasy
    398987889, --Ordinary Days
    1117396305, --Oh wait, it's you.
    885996042, --Action Winter Journey
    919231299, --Sprawling Idiot Effigy
    743466274, --Good Day Sunshine
    727411183, --Knife Fight
    1402748531, --The Earth Is Counting On You!
    595230126 --Robot Language
    }
 
 
 
--The reality of my life isn't real but a Universe -makhail07
wait()
local plr = owner
print('Local User is '..plr.Name)
print('CADUCUS? Loaded')
print('Let good be gone, Let souls be taken. through the fallen god.')
local char = plr.Character
local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Really black")
 
-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil
RW = Instance.new("Weld")
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"]
LSH = tors["Left Shoulder"]
RSH.Parent = nil
LSH.Parent = nil
RW.Name = "RW"
RW.Part0 = tors
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0)
RW.Part1 = ra
RW.Parent = tors
LW.Name = "LW"
LW.Part0 = tors
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0)
LW.Part1 = la
LW.Parent = tors
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")
 
frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false
 
 
lastframe = tick()
script.Heartbeat:Fire()
 
 
game:GetService("RunService").Heartbeat:connect(function(s, p)
    tf = tf + s
    if tf >= frame then
        if allowframeloss then
            script.Heartbeat:Fire()
            lastframe = tick()
        else
            for i = 1, math.floor(tf / frame) do
                script.Heartbeat:Fire()
            end
            lastframe = tick()
        end
        if tossremainder then
            tf = 0
        else
            tf = tf - frame * math.floor(tf / frame)
        end
    end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------
 
-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
    if num == 0 or num == nil then
        game:service("RunService").Stepped:wait(0)
    else
        for i = 0, num do
            game:service("RunService").Stepped:wait(0)
        end
    end
end
function thread(f)
    coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
    local qa = {
        QuaternionFromCFrame(a)
    }
    local qb = {
        QuaternionFromCFrame(b)
    }
    local ax, ay, az = a.x, a.y, a.z
    local bx, by, bz = b.x, b.y, b.z
    local _t = 1 - t
    return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
    local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
    local trace = m00 + m11 + m22
    if trace > 0 then
        local s = math.sqrt(1 + trace)
        local recip = 0.5 / s
        return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
    else
        local i = 0
        if m00 < m11 then
            i = 1
        end
        if m22 > (i == 0 and m00 or m11) then
            i = 2
        end
        if i == 0 then
            local s = math.sqrt(m00 - m11 - m22 + 1)
            local recip = 0.5 / s
            return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
        elseif i == 1 then
            local s = math.sqrt(m11 - m22 - m00 + 1)
            local recip = 0.5 / s
            return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
        elseif i == 2 then
            local s = math.sqrt(m22 - m00 - m11 + 1)
            local recip = 0.5 / s
            return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
        end
    end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
    local xs, ys, zs = x + x, y + y, z + z
    local wx, wy, wz = w * xs, w * ys, w * zs
    local xx = x * xs
    local xy = x * ys
    local xz = x * zs
    local yy = y * ys
    local yz = y * zs
    local zz = z * zs
    return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
    local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
    local startInterp, finishInterp
    if cosTheta >= 1.0E-4 then
        if 1 - cosTheta > 1.0E-4 then
            local theta = math.acos(cosTheta)
            local invSinTheta = 1 / Sin(theta)
            startInterp = Sin((1 - t) * theta) * invSinTheta
            finishInterp = Sin(t * theta) * invSinTheta
        else
            startInterp = 1 - t
            finishInterp = t
        end
    elseif 1 + cosTheta > 1.0E-4 then
        local theta = math.acos(-cosTheta)
        local invSinTheta = 1 / Sin(theta)
        startInterp = Sin((t - 1) * theta) * invSinTheta
        finishInterp = Sin(t * theta) * invSinTheta
    else
        startInterp = t - 1
        finishInterp = t
    end
    return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
    return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create
 
 
CFuncs = {
    Part = {
        Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
            local Part = Create("Part")({
                Parent = Parent,
                Reflectance = Reflectance,
                Transparency = Transparency,
                CanCollide = false,
                Locked = true,
                BrickColor = BrickColor.new(tostring(BColor)),
                Name = Name,
                Size = Size,
                Material = Material
            })
            RemoveOutlines(Part)
            return Part
        end
    },
    Mesh = {
        Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
            local Msh = Create(Mesh)({
                Parent = Part,
                Offset = OffSet,
                Scale = Scale
            })
            if Mesh == "SpecialMesh" then
                Msh.MeshType = MeshType
                Msh.MeshId = MeshId
            end
            return Msh
        end
    },
    Mesh = {
        Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
            local Msh = Create(Mesh)({
                Parent = Part,
                Offset = OffSet,
                Scale = Scale
            })
            if Mesh == "SpecialMesh" then
                Msh.MeshType = MeshType
                Msh.MeshId = MeshId
            end
            return Msh
        end
    },
    Weld = {
        Create = function(Parent, Part0, Part1, C0, C1)
            local Weld = Create("Weld")({
                Parent = Parent,
                Part0 = Part0,
                Part1 = Part1,
                C0 = C0,
                C1 = C1
            })
            return Weld
        end
    },
    Sound = {
        Create = function(id, par, vol, pit)
            coroutine.resume(coroutine.create(function()
                local S = Create("Sound")({
                    Volume = vol,
                    Pitch = pit or 1,
                    SoundId = id,
                    Parent = par or workspace
                })
                wait()
                S:play()
                game:GetService("Debris"):AddItem(S, 6)
            end))
        end
    },
    ParticleEmitter = {
        Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
            local fp = Create("ParticleEmitter")({
                Parent = Parent,
                Color = ColorSequence.new(Color1, Color2),
                LightEmission = LightEmission,
                Size = Size,
                Texture = Texture,
                Transparency = Transparency,
                ZOffset = ZOffset,
                Acceleration = Accel,
                Drag = Drag,
                LockedToPart = LockedToPart,
                VelocityInheritance = VelocityInheritance,
                EmissionDirection = EmissionDirection,
                Enabled = Enabled,
                Lifetime = LifeTime,
                Rate = Rate,
                Rotation = Rotation,
                RotSpeed = RotSpeed,
                Speed = Speed,
                VelocitySpread = VelocitySpread
            })
            return fp
        end
    }
}
function RemoveOutlines(part)
    part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
    local Part = Create("Part")({
        formFactor = FormFactor,
        Parent = Parent,
        Reflectance = Reflectance,
        Transparency = Transparency,
        CanCollide = false,
        Locked = true,
        BrickColor = BrickColor.new(tostring(BColor)),
        Name = Name,
        Size = Size,
        Material = Material
    })
    RemoveOutlines(Part)
    return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
    local Msh = Create(Mesh)({
        Parent = Part,
        Offset = OffSet,
        Scale = Scale
    })
    if Mesh == "SpecialMesh" then
        Msh.MeshType = MeshType
        Msh.MeshId = MeshId
    end
    return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
    local Weld = Create("Weld")({
        Parent = Parent,
        Part0 = Part0,
        Part1 = Part1,
        C0 = C0,
        C1 = C1
    })
    return Weld
end
 
 
-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
    local fp = IT("Part")
    fp.formFactor = formfactor
    fp.Parent = parent
    fp.Reflectance = reflectance
    fp.Transparency = transparency
    fp.CanCollide = false
    fp.Locked = true
    fp.BrickColor = brickcolor
    fp.Name = name
    fp.Size = size
    fp.Position = tors.Position
    RemoveOutlines(fp)
    fp.Material = "SmoothPlastic"
    fp:BreakJoints()
    return fp
end
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
    local mesh = IT(Mesh)
    mesh.Parent = part
    if Mesh == "SpecialMesh" then
        mesh.MeshType = meshtype
    if meshid ~= "nil" then
        mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
        end
    end
    mesh.Offset = offset
    mesh.Scale = scale
    return mesh
end
 
function Magic(bonuspeed, type, pos, scale, value, color, MType)
    local type = type
    local rng = Instance.new("Part", char)
    rng.Anchored = true
    rng.BrickColor = color
    rng.CanCollide = false
    rng.FormFactor = 3
    rng.Name = "Ring"
    rng.Material = "Neon"
    rng.Size = Vector3.new(1, 1, 1)
    rng.Transparency = 0
    rng.TopSurface = 0
    rng.BottomSurface = 0
    rng.CFrame = pos
    local rngm = Instance.new("SpecialMesh", rng)
    rngm.MeshType = MType
    rngm.Scale = scale
    local scaler2 = 1
    if type == "Add" then
        scaler2 = 1 * value
    elseif type == "Divide" then
        scaler2 = 1 / value
    end
    coroutine.resume(coroutine.create(function()
        for i = 0, 10 / bonuspeed, 0.1 do
            swait()
            if type == "Add" then
                scaler2 = scaler2 - 0.01 * value / bonuspeed
            elseif type == "Divide" then
                scaler2 = scaler2 - 0.01 / value * bonuspeed
            end
            rng.Transparency = rng.Transparency + 0.01 * bonuspeed
            rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
        end
        rng:Destroy()
    end))
end
 
function Eviscerate(dude)
    if dude.Name ~= char then
        local bgf = IT("BodyGyro", dude.Head)
        bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
        local val = IT("BoolValue", dude)
        val.Name = "IsHit"
        local ds = coroutine.wrap(function()
            dude:WaitForChild("Head"):BreakJoints()
            wait(0.5)
            target = nil
            coroutine.resume(coroutine.create(function()
                for i, v in pairs(dude:GetChildren()) do
                    if v:IsA("Accessory") then
                        v:Destroy()
                    end
                    if v:IsA("Humanoid") then
                        v:Destroy()
                    end
                    if v:IsA("CharacterMesh") then
                        v:Destroy()
                    end
                    if v:IsA("Model") then
                        v:Destroy()
                    end
                    if v:IsA("Part") or v:IsA("MeshPart") then
                        for x, o in pairs(v:GetChildren()) do
                            if o:IsA("Decal") then
                                o:Destroy()
                            end
                        end
                        coroutine.resume(coroutine.create(function()
                            v.Material = "Neon"
                            v.CanCollide = false
                            local PartEmmit1 = IT("ParticleEmitter", v)
                            PartEmmit1.LightEmission = 1
                            PartEmmit1.Texture = "rbxassetid://1523916715"
                            PartEmmit1.Color = ColorSequence.new(Color3.new(0, 0, 0))
                            PartEmmit1.Rate = 150
                            PartEmmit1.Lifetime = NumberRange.new(1)
                            PartEmmit1.Size = NumberSequence.new({
                                NumberSequenceKeypoint.new(0, 0.75, 0),
                                NumberSequenceKeypoint.new(1, 0, 0)
                            })
                            PartEmmit1.Transparency = NumberSequence.new({
                                NumberSequenceKeypoint.new(0, 0, 0),
                                NumberSequenceKeypoint.new(1, 1, 0)
                            })
                            PartEmmit1.Speed = NumberRange.new(0, 0)
                            PartEmmit1.VelocitySpread = 30000
                            PartEmmit1.Rotation = NumberRange.new(-500, 500)
                            PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
                            local BodPoss = IT("BodyPosition", v)
                            BodPoss.P = 3000
                            BodPoss.D = 1000
                            BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
                            BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
                            v.Color = maincolor.Color
                            coroutine.resume(coroutine.create(function()
                                for i = 0, 49 do
                                    swait(1)
                                    v.Transparency = v.Transparency + 0.08
                                end
                                wait(0.5)
                                PartEmmit1.Enabled = false
                                wait(3)
                                v:Destroy()
                                dude:Destroy()
                            end))
                        end))
                    end
                end
            end))
        end)
        ds()
    end
end
 
function FindNearestHead(Position, Distance, SinglePlayer)
    if SinglePlayer then
        return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
    end
    local List = {}
    for i, v in pairs(workspace:GetChildren()) do
        if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
            table.insert(List, v)
        end
    end
    return List
end
 
function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
    local type = type
    local rng = Instance.new("Part", char)
    rng.Anchored = true
    rng.BrickColor = color
    rng.CanCollide = false
    rng.FormFactor = 3
    rng.Name = "Ring"
    rng.Material = "Neon"
    rng.Size = Vector3.new(1, 1, 1)
    rng.Transparency = 0
    rng.TopSurface = 0
    rng.BottomSurface = 0
    rng.CFrame = pos
    rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
    local rngm = Instance.new("SpecialMesh", rng)
    rngm.MeshType = MType
    rngm.Scale = Vector3.new(x1, y1, z1)
    local scaler2 = 1
    local speeder = FastSpeed
    if type == "Add" then
        scaler2 = 1 * value
    elseif type == "Divide" then
        scaler2 = 1 / value
    end
    coroutine.resume(coroutine.create(function()
        for i = 0, 10 / bonuspeed, 0.1 do
            swait()
            if type == "Add" then
                scaler2 = scaler2 - 0.01 * value / bonuspeed
            elseif type == "Divide" then
                scaler2 = scaler2 - 0.01 / value * bonuspeed
            end
            speeder = speeder - 0.01 * FastSpeed * bonuspeed
            rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
            rng.Transparency = rng.Transparency + 0.01 * bonuspeed
            rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
        end
        rng:Destroy()
    end))
end
 
function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
    NumberSequenceKeypoint.new(0, 1, 0),
    NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
    NumberSequenceKeypoint.new(0, 0, 0),
    NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
    if hit.Parent == char then
    soul:Destroy()
    end
end)
wait(1.2)
while soul do
    swait()
    PartEmmit1.Color = ColorSequence.new(maincolor.Color)
    BodPoss.Position = tors.Position
end
end)
    soulst()
    end
end
function FaceMouse()
local   Cam = workspace.CurrentCamera
    return {
        CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
        Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
    }
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
    local NSound = nil
    coroutine.resume(coroutine.create(function()
        NSound = IT("Sound", PARENT)
        NSound.Volume = VOLUME
        NSound.Pitch = PITCH
        NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
        swait()
        NSound:play()
        game:GetService("Debris"):AddItem(NSound, 10)
    end))
    return NSound
end
function CameraEnshaking(Length, Intensity)
    coroutine.resume(coroutine.create(function()
        local intensity = 1 * Intensity
        local rotM = 0.01 * Intensity
        for i = 0, Length, 0.1 do
            swait()
            intensity = intensity - 0.05 * Intensity / Length
            rotM = rotM - 5.0E-4 * Intensity / Length
            hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
            cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
        end
        hum.CameraOffset = Vector3.new(0, 0, 0)
    end))
end
 
function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
    local NEWMESH = Instance.new(MESH)
    if MESH == "SpecialMesh" then
        NEWMESH.MeshType = MESHTYPE
        if MESHID ~= "nil" and MESHID ~= "" then
            NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
        end
        if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
            NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
        end
    end
    NEWMESH.Offset = OFFSET or Vector3.new(0, 0, 0)
    NEWMESH.Scale = SCALE
    NEWMESH.Parent = PARENT
    return NEWMESH
end
 
function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
    local NEWPART = Instance.new("Part")
    NEWPART.formFactor = FORMFACTOR
    NEWPART.Reflectance = REFLECTANCE
    NEWPART.Transparency = TRANSPARENCY
    NEWPART.CanCollide = false
    NEWPART.Locked = true
    NEWPART.Anchored = true
    if ANCHOR == false then
        NEWPART.Anchored = false
    end
    NEWPART.BrickColor = BrickColor.new(tostring(BRICKCOLOR))
    NEWPART.Name = NAME
    NEWPART.Size = SIZE
    NEWPART.Position = tors.Position
    NEWPART.Material = MATERIAL
    NEWPART:BreakJoints()
    NEWPART.Parent = PARENT
    return NEWPART
end
 
function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
    local frame = IT("Frame")
    frame.BackgroundTransparency = TRANSPARENCY
    frame.BorderSizePixel = BORDERSIZEPIXEL
    frame.Position = POSITION
    frame.Size = SIZE
    frame.BackgroundColor3 = COLOR
    frame.BorderColor3 = BORDERCOLOR
    frame.Name = NAME
    frame.Parent = PARENT
    return frame
end
 
UD2 = UDim2.new
 
function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
    local label = IT("TextLabel")
    label.BackgroundTransparency = 1
    label.Size = UD2(1, 0, 1, 0)
    label.Position = UD2(0, 0, 0, 0)
    label.TextColor3 = TEXTCOLOR
    label.TextStrokeTransparency = STROKETRANSPARENCY
    label.TextTransparency = TRANSPARENCY
    label.FontSize = TEXTFONTSIZE
    label.Font = TEXTFONT
    label.BorderSizePixel = BORDERSIZEPIXEL
    label.TextScaled = false
    label.Text = TEXT
    label.Name = NAME
    label.Parent = PARENT
    return label
end
 
local Particle = IT("ParticleEmitter",nil)
Particle.Enabled = false
Particle.LightEmission = 0.2
Particle.Rate = 150
Particle.ZOffset = 1
Particle.Rotation = NumberRange.new(-180, 180)
 
function ParticleEmitter(Table)
    local PRTCL = Particle:Clone()
    local Color1 = Table.Color1 or Color3.new(1,1,1)
    local Color2 = Table.Color2 or Color3.new(1,1,1)
    local Speed = Table.Speed or 5
    local Drag = Table.Drag or 0
    local Size1 = Table.Size1 or 1
    local Size2 = Table.Size2 or 5
    local Lifetime1 = Table.Lifetime1 or 1
    local Lifetime2 = Table.Lifetime2 or 1.5
    local Parent = Table.Parent or tors
    local Emit = Table.Emit or 100
    local Offset = Table.Offset or 360
    local Acel = Table.Acel or Vector3.new(0,0,0)
    local Enabled = Table.Enabled or false
    local Texture = Table.Texture or "281983280"
    local RotS = Table.RotSpeed or NumberRange.new(-15, 15)
    local Trans1 = Table.Transparency1 or 0
    local Trans2 = Table.Transparency2 or 0
    PRTCL.Parent = Parent
    PRTCL.RotSpeed = RotS
    PRTCL.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,Trans1),NumberSequenceKeypoint.new(1,Trans2)})
    PRTCL.Texture = "http://www.roblox.com/asset/?id="..Texture
    PRTCL.Color = ColorSequence.new(Color1,Color2)
    PRTCL.Size = NumberSequence.new(Size1,Size2)
    PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
    PRTCL.Speed = NumberRange.new(Speed)
    PRTCL.VelocitySpread = Offset
    PRTCL.Drag = Drag
    PRTCL.Acceleration = Acel
    if Enabled == false then
        PRTCL:Emit(Emit)
        game:GetService("Debris"):AddItem(PRTCL,Lifetime2)
    else
        PRTCL.Enabled = true
    end
    return PRTCL
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------
 
 
-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1.4
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 1066344174
local SONG2 = 0
local Music = Instance.new("Sound",tors)
Music.Volume = 2.5
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
local VALUE1 = false
local VALUE2 = false
local HOLD = false
local KEYHOLD = false
----------------------------------------------------------------------------------
hum.WalkSpeed = 18
hum.JumpPower = 130
hum.Animator.Parent = nil
----------------------------------------------------------------------------------
local naeeym2 = IT("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,15)
naeeym2.StudsOffset = Vector3.new(0,2,0)
naeeym2.MaxDistance = 75
naeeym2.Adornee = hed
naeeym2.Name = "Name"
--naeeym2.PlayerToHideFrom = Player
local tecks2 = IT("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "CADUCUS?"
tecks2.Font = "Garamond"
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.fromRGB(0, 0, 0)
tecks2.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2

char.Head.face.Texture = "http://www.roblox.com/asset/?id=176777497"

local maincol = Color3.new(0,0,0)
local maincol2 = tors.Color
------------------------------------
char["Body Colors"].HeadColor = BrickColor.new("Really black")
char["Body Colors"].TorsoColor = BrickColor.new("Really black")
char["Body Colors"].LeftArmColor = BrickColor.new("Really black")
char["Body Colors"].RightArmColor = BrickColor.new("Really black")
char["Body Colors"].LeftLegColor = BrickColor.new("Really black")
char["Body Colors"].RightLegColor = BrickColor.new("Really black")

shirt = Instance.new("Shirt", char)
shirt.Name = "Shirt"
pants = Instance.new("Pants", char)
pants.Name = "Pants"
char.Shirt.ShirtTemplate = "rbxassetid://767518226"
char.Pants.PantsTemplate = "rbxassetid://2237302446"

----------------------------------------------------------------------------------
PlayerGui = plr.PlayerGui
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "Weapon GUI"
 
local SKILLTEXTCOLOR = Color3.new(0,0,0)
local SKILLFONT = "Antique"
local SKILLTEXTSIZE = 6
 
local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), Color3.new(0,0,0), Color3.new(0, 0, 0), "Skill 1 Frame")
local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.86, 0), UD2(0.26, 0, 0.07, 0), Color3.new(0,0,0), Color3.new(0, 0, 0), "Skill 2 Frame")
local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.82, 0), UD2(0.26, 0, 0.07, 0), Color3.new(0,0,0), Color3.new(0, 0, 0), "Skill 3 Frame")
local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.78, 0), UD2(0.26, 0, 0.07, 0), Color3.new(0,0,0), Color3.new(0, 0, 0), "Skill 4 Frame")
local SKILL5FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.74, 0), UD2(0.26, 0, 0.07, 0), Color3.new(0,0,0), Color3.new(0, 0, 0), "Skill 5 Frame")
 
local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z] Shadow's Victory", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 1, "Text 1")
local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B] Eruption", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 1, "Text 2")
local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C] Chaos", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 1, "Text 3")
local SKILL4TEXT = CreateLabel(SKILL4FRAME, "[V] Death's Wish", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 1, "Text 4")
local SKILL5TEXT = CreateLabel(SKILL5FRAME, "[X] Shadows Whisper", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 1, "Text 5")
-------------------------------------------------------
--End Customization--
-------------------------------------------------------
 
 
-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
function Shadom_Circle()
   
end
function Flame_Burst()
    local target = nil
    local targettorso = nil
    if mouse.Target.Parent ~= char and mouse.Target.Parent.Parent ~= char and mouse.Target.Parent:FindFirstChild("Humanoid") ~= nil then
        if mouse.Target.Parent.Humanoid.PlatformStand == false then
            target = mouse.Target.Parent.Humanoid
            target2 = mouse.Target.Parent
            targettorso = mouse.Target.Parent:FindFirstChild("Torso") or mouse.Target.Parent:FindFirstChild("UpperTorso")
        end
    end
    if target ~= nil then
        attack = true
        hum.WalkSpeed = 0
        for i = 0, 3.4, 0.1 do
            swait()
            hum.WalkSpeed = 0
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 - 0.04 * Sin(sine / 24) * Player_Size, 0 + 0.04 * Sin(sine / 12) * Player_Size, 0 + 0.05 * Player_Size * Cos(sine / 12)) * angles(Rad(0 - 2.5 * Sin(sine / 12)), Rad(0 - 2.5 * Sin(sine / 24)), Rad(45)), 0.1)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(15), Rad(0), Rad(-45)), 0.1)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0.06  - 0.05 * Player_Size * Cos(sine / 12), -0.01 * Player_Size) * angles(Rad(0 - 2.5 * Sin(sine / 12)), Rad(79), Rad(0)) * angles(Rad(-6 - 2.5 * Sin(sine / 24)), Rad(0), Rad(0)), 0.1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.06  - 0.05 * Player_Size * Cos(sine / 12), -0.01 * Player_Size) * angles(Rad(0 - 2.5 * Sin(sine / 12)), Rad(-79), Rad(0)) * angles(Rad(-6 + 2.5 * Sin(sine / 24)), Rad(0), Rad(0)), 0.1)
            RW.C0 = clerp(RW.C0, CF(1.5 * Player_Size, 0.5 + 0.02 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(-15), Rad(46 + 4.5 * Sin(sine / 12))), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5 * Player_Size, 0.5 + 0.02 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-46 - 4.5 * Sin(sine / 12))), 0.1)
        end
        --ParticleEmitter({Transparency1 = 1, Transparency2 = 0, Speed = 5, Acel = Vector3.new(0,12,0), RotSpeed = NumberRange.new(-150, 150), Drag = 0, Size1 = 3, Size2 = 0, Lifetime1 = 0.4, Lifetime2 = 1, Parent = targettorso, Emit = 300, Offset = 360, Enabled = false, Color1 = Color3.new(0,0,0), Color2 = Color3.new(0,0,0), Texture = "1523916715"})
        --targettorso:BreakJoints()
        for i = 0, 3.4, 0.1 do
            swait()
            hum.WalkSpeed = 0
            ParticleEmitter({Transparency1 = 1, Transparency2 = 0, Speed = 5, Acel = Vector3.new(0,12,0), RotSpeed = NumberRange.new(-150, 150), Drag = 0, Size1 = 3, Size2 = 0, Lifetime1 = 0.4, Lifetime2 = 1, Parent = targettorso, Emit = 300, Offset = 360, Enabled = false, Color1 = Color3.new(0,0,0), Color2 = Color3.new(0,0,0), Texture = "1523916715"})
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 - 0.04 * Sin(sine / 24) * Player_Size, 0 + 0.04 * Sin(sine / 12) * Player_Size, 0 + 0.05 * Player_Size * Cos(sine / 12)) * angles(Rad(0 - 2.5 * Sin(sine / 12)), Rad(0 - 2.5 * Sin(sine / 24)), Rad(45)), 0.1)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(15), Rad(0), Rad(-45)), 0.1)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0.06  - 0.05 * Player_Size * Cos(sine / 12), -0.01 * Player_Size) * angles(Rad(0 - 2.5 * Sin(sine / 12)), Rad(79), Rad(0)) * angles(Rad(-6 - 2.5 * Sin(sine / 24)), Rad(0), Rad(0)), 0.1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.06  - 0.05 * Player_Size * Cos(sine / 12), -0.01 * Player_Size) * angles(Rad(0 - 2.5 * Sin(sine / 12)), Rad(-79), Rad(0)) * angles(Rad(-6 + 2.5 * Sin(sine / 24)), Rad(0), Rad(0)), 0.1)
            RW.C0 = clerp(RW.C0, CF(1.5 * Player_Size, 0.5 + 0.02 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(135), Rad(-.6), Rad(46 + 4.5 * Sin(sine / 12))), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5 * Player_Size, 0.5 + 0.02 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-46 - 4.5 * Sin(sine / 12))), 0.1)
        end
        for i, v in pairs(target2:GetChildren()) do
            if(not char:IsAncestorOf(v))then
                local hum = (v and v.Parent and v.Parent:FindFirstChildOfClass'Humanoid')
                local hedder = (v and v.Parent and v.Parent:FindFirstChild'Head')
                if(hum and hedder and hum.Health > 0)then
                Eviscerate(v.Parent)
            end
            end
        end
        attack = false
        hum.WalkSpeed = 18
    end
end
-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
    if (VALUE1 == false and attack == false) or VALUE2 == true then
        if key == "q" then
            if VALUE2 == false then

            elseif VALUE2 == true then
                VALUE2 = false
            end
        end
    end
    if attack == false then
        if key == 't' then
            Cso("907332040", hed, 10, 1.1)
        elseif key == 'z' then
            Shadom_Circle()
        elseif key == 'b' then
            Flame_Burst()
        end
    end
end)
 
mouse.KeyDown:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 2
        hum.WalkSpeed = 38.82
    end
end)
mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 1
        hum.WalkSpeed = 18
    end
end)
 
 
 
 
 
 
-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
while true do
    swait()
    sine = sine + change
    local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
    local velderp = root.Velocity.y
    hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
    if equipped == true or equipped == false then
        if attack == false then
            idle = idle + 1
        else
            idle = 0
        end
        if 1 < root.Velocity.y and hitfloor == nil then
            Anim = "Jump"
            if attack == false then
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-5), Rad(0), Rad(0)), 0.15)
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
                RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
                LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
            end
        elseif -1 > root.Velocity.y and hitfloor == nil then
            Anim = "Fall"
            if attack == false then
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-24), Rad(0), Rad(0)), 0.15)
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(35 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
                RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(50)), 0.15)
                LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(40)), 0.15)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(75 + 4.5 * Sin(sine / 20))), 0.1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-75 - 4.5 * Sin(sine / 20))), 0.1)
            end
        elseif torvel < 1 and hitfloor ~= nil then
            Anim = "Idle"
            change = 1
            if attack == false then
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 2 + 0.25* Player_Size * Cos(sine / 12)) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
                tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(15 - 6.5 * Sin(sine / 12)), Rad(0), Rad(0)), 0.05)
                RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.15 * Cos(sine / 20)* Player_Size, -0.1* Player_Size) * angles(Rad(0), Rad(76), Rad(0)) * angles(Rad(-8.5 - 6.5 * Sin(sine / 12)), Rad(0), Rad(15)), 0.1)
                LH.C0 = clerp(LH.C0, CF(-1.1* Player_Size, -0.6 - 0.15 * Cos(sine / 20)* Player_Size, -0.3* Player_Size) * angles(Rad(0), Rad(-76), Rad(0)) * angles(Rad(-8.5 - 6.5 * Sin(sine / 12)), Rad(15), Rad(25)), 0.1)
                RW.C0 = clerp(RW.C0, CF(1.4* Player_Size, 0.4 + 0.08 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(25 - 6.5 * Cos(sine / 12)), Rad(-.6), Rad(13 + 6.5 * Sin(sine / 12))), 0.1)
                LW.C0 = clerp(LW.C0, CF(-1.4* Player_Size, 0.4 + 0.08 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(25 - 6.5 * Cos(sine / 12)), Rad(-.6), Rad(-13 - 6.5 * Sin(sine / 12))), 0.1)
            end
        elseif torvel > 2 and torvel < 25 and hitfloor ~= nil then
            Anim = "Walk"
            change = 1
            if attack == false then
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 2 + 0.25* Player_Size * Cos(sine / 12)) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
                tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-15 - 6.5 * Sin(sine / 12)), Rad(20), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.15 * Cos(sine / 20)* Player_Size, -0.1* Player_Size) * angles(Rad(0), Rad(76), Rad(0)) * angles(Rad(-18.5 - 6.5 * Sin(sine / 12)), Rad(0), Rad(-35)), 0.1)
                LH.C0 = clerp(LH.C0, CF(-1.1* Player_Size, -0.6 - 0.15 * Cos(sine / 20)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(-76), Rad(0)) * angles(Rad(-18.5 - 6.5 * Sin(sine / 12)), Rad(15), Rad(35)), 0.1)
                RW.C0 = clerp(RW.C0, CF(1.4* Player_Size, 0.4 + 0.08 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(-45 - 6.5 * Cos(sine / 12)), Rad(-.6), Rad(25 + 6.5 * Sin(sine / 12))), 0.1)
                LW.C0 = clerp(LW.C0, CF(-1.4* Player_Size, 0.4 + 0.08 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(-45 - 6.5 * Cos(sine / 12)), Rad(-.6), Rad(-25 - 6.5 * Sin(sine / 12))), 0.1)
            end
        elseif torvel >= 25 and hitfloor ~= nil then
            Anim = "Sprint"
            change = 1.35
            if attack == false then
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-2.5 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
            RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925* Player_Size - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
            LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925* Player_Size + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(110)  * Cos(sine / 7) , Rad(0), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-110)  * Cos(sine / 7) , Rad(0) , Rad(-13) + la.RotVelocity.Y / 75), 0.15)
            end
        end
    end
    for _, c in pairs(char:GetChildren()) do
        if c.ClassName == "Part" and c.Name ~= "Detail" and c.Name ~= "Add-ons" then
            c.Material = "Fabric"
            if c:FindFirstChildOfClass("ParticleEmitter") then
                c:FindFirstChildOfClass("ParticleEmitter"):remove()
            end
            if c ~= hed then
                c.Color = Color3.new(0, 0, 0)
            else
                c.Color = Color3.new(0, 0, 0)
            end
        elseif c.ClassName == "CharacterMesh" or c.ClassName == "Accessory" or c.Name == "Body Colors" then
            c:remove()
        elseif (c.ClassName == "Shirt" or c.ClassName == "Pants") and c.Name ~= "Cloth" then
            c:remove()
        end
    end
    Music.SoundId = "rbxassetid://"..SONG
    Music.Looped = true
    Music.Pitch = 1
    Music.Volume = 5
    Music.Parent = tors
    Music:Resume()
    if 0 < #Effects then
        for e = 1, #Effects do
            if Effects[e] ~= nil then
                local Thing = Effects[e]
                if Thing ~= nil then
                    local Part = Thing[1]
                    local Mode = Thing[2]
                    local Delay = Thing[3]
                    local IncX = Thing[4]
                    local IncY = Thing[5]
                    local IncZ = Thing[6]
                    if 1 >= Thing[1].Transparency then
                        if Thing[2] == "Block1" then
                            Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                            local Mesh = Thing[1].Mesh
                            Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                        elseif Thing[2] == "Block2" then
                            Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
                            local Mesh = Thing[7]
                            Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                        elseif Thing[2] == "Block3" then
                            Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
                            local Mesh = Thing[7]
                            Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                        elseif Thing[2] == "Cylinder" then
                            local Mesh = Thing[1].Mesh
                            Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                        elseif Thing[2] == "Blood" then
                            local Mesh = Thing[7]
                            Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
                            Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                        elseif Thing[2] == "Elec" then
                            local Mesh = Thing[1].Mesh
                            Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                        elseif Thing[2] == "Disappear" then
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                        elseif Thing[2] == "Shatter" then
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
                            Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
                            Thing[6] = Thing[6] + Thing[5]
                        end
                    else
                        Part.Parent = nil
                        table.remove(Effects, e)
                    end
                end
            end
        end
    end
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------